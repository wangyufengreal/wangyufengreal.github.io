---
title: (1) 从零开始的 Senior MLE (cv) 之路 - Python 工程化入门
date: 2025-11-06 08:00:00 +0800
categories: [技术]
tags: [cv, Python]
---

## Why Python？

在机器学习的研究和工程领域，Python 均作为首选语言而存在，总结来看主要有以下原因

- 成熟的生态: 有 `PyTroch, TensorFlow, Numpy, OpenCV-python, scikit-learn, Matplotlib, Seaborn...`，简单来说，在 Python 的世界，几乎可以只用几行 `import` 就能够搭起一个完整的以及 SOTA 的 ML 工作流，而无需重复造轮子。Python 的生态能够发展起来，实际应该归功于 `Numpy, SciPy, scikit-learn` 等的开发（由于语言特性，科研人员可以方便地使用），因此在深度学习浪潮来临的时候，科研界就选择了 Python，然后其生态就如滚雪球一般快速成长了起来，风靡了科研界和工业界
- 低门槛，高开发效率：语法简单，可读性强，使用者可以更专注于算法和逻辑本身，而非内存管理，指针和编译等问题。
- 胶水语言：由于语法简单和动态特性，以及语言设计之初就被考虑的扩展性(CPython 提供了一套 C API，因此 Python 可以直接调用 C/C++ 编写的函数)，让它比其它更复杂，且缺乏交互性的语言（如 C++）更适合作为胶水性质的语言存在。

在 CV 领域，不得不提到 C++，因为在传统图像算法领域，C++ 扮演着极其关键的角色，大多数算法是由 C++ 直接开发的。而到了今天，C++ 更多作为基石和生产环境应用的编码语言而存在。因为 Python 本身的性能劣势，几乎所有的 Python AI 生态都是由 C/C++ 构建起来的。而在生产环境中，由于资源受限和极致性能的要求，如推理等任务就会交由 C++ 实现。

至此 Python 的关键性已经不言而喻，那么作为一个有着成为 Senior MLE 志向的工程师，而非一个脚本小子，就有必要理解如何写出更好，更容易维护的 Python 程序，而非仅仅追求能够将功能实现。因此在正式开始探索机器学习领域之前，认识到 Python 的工程化就极为重要。

## Why Python 工程化？

- 代码质量与可维护性：
  - 未工程化：代码逻辑胡乱，命名随意，模块高度耦合，当需要修改 bug 或者添加新功能时，修改成本极高，且容易引入新的 bug。
  - 工程化后：遵循编码规范（如 PEP 8），采用模块化设计，同时编写清晰的文档和注释，这不仅让代码变得容易理解，而且使得未来的维护，重构和功能扩展变得轻松。

- 健壮性和可靠性：
  - 未工程化：没有单元测试，没有集成测试，没有异常处理。
  - 工程化后：严格的单元测试，集成测试和异常处理机制，能确保代码在各种边界条件下都能按预期工作。

- 提升团队效率：
  - 未工程化：每个人的开发环境，代码风格和依赖库版本都不一样，A 写的代码在 B 的环境中跑不起来。代码合并时充满冲突，而且项目目录结构不清晰，协作效率极低。
  - 工程化后：统一的开发环境，统一的代码风格，清晰的项目目录结构，规范的版本控制。

- 交付工作流：
  - 未工程化：充斥着人工操作，依赖于记忆或部署文档，非常容易出错。
  - 工程化后：通过 CI/CD 流程，将测试，打包和部署等步骤自动化，减轻了人为失误的风险，为项目的持久运行提供保障。

总之，Python 的工程化就是解决 Python 项目的规模化和长期性的问题。

## 代码质量的工程化

### 模块化

就是将一个庞大的，复杂的软件系统，拆分成一系列更小的，独立的模块的过程。基于高内聚，低耦合的拆分原则。模块化将软件变得易于维护，可扩展和可靠。

- 高内聚：
  - 含义：一个模块只做一件事，并把它做好。也就是一个模块里的类/函数/变量都应该服务于一个单一的，清晰的目的。
  - 例子：一个 `database.py` 模块应该只包含与数据库连接，查询，写入相关的代码。它不应该直到任何ui相关的内容。
  - 好处：极大地降低开发和维护的心智负担，且可以将不同模块分发给不同的人员进行维护。
- 低耦合：
  - 含义：模块之间应尽可能少地相互依赖。
  - 例子：比如一个 `user.py` 负责用户的注册，登录和注销，它不应该直接去写 SQL 查询语句，而应该去调用 `database.py` 模块提供的一个公共函数，如 `database.register_user(email, password)`。
  - 好处：假如数据库由 MySQL 切换为了 PostgreSQL，`user.py` 无需关注这些变化，只要 `database.py` 模块的维护者确保这个接口函数还可以使用，那么 `user.py` 的维护者无需更改一行代码。

基于上述原则进行软件系统的模块化，开发团队将获得极大的收益。

- 可维护性：当出现bug，我们不再需要大海捞针。如果 `支付` 功能出现问题，我们只需要去检查 `payment.py` 模块。

- 可复用性：假设在项目 A 中，我们编写了一个功能强大的模块 `a.py`, 然后我们可以在任何新项目中使用 `import a` 来重用这些功能，而不用重新开发。

- 可测试性：因为模块高内聚，低耦合的特性，我们可以使用 Mock 的方式，轻松地模拟外部依赖的接口（比如 `user.py` 依赖的 `database.register_user(email, password)`），而不需要一个真实运行的数据库。这是能够编写出完备的单元测试的前置条件。

- 并行开发：不同模块可以由不同的人同时开发，只要提前定义好接口（如 `database.register_user(email, password)`），就可以互补干扰地并行工作。

下面是关于 Python 的模块化的说明。

- 文件即模块。每一个 py 文件都是一个模块。

- 文件夹即包。放一个 `__init__.py` 即可。

- `import` 就是连接模块的胶水。

- 接口约束。Python 没有 public 和 private 关键字，我们约定公共接口命名为正常函数或类命名，如 `get_user()`，而对于内部实现由单下划线开头，如 `_create_db_connection()`，这是一种强烈的暗示，告诉调用者这是内部实现，调用后果自负。（因为内部实现可能这个版本存在下个版本就消失了，而公共接口的变更是一件非常重大的事情，常规来说会一直被维护）
