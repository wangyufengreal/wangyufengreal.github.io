---
title: (1) 从零开始的 Senior MLE (cv) 之路 - Python 工程化入门
date: 2025-11-06 08:00:00 +0800
categories: [技术]
tags: [cv, Python]
---

## Why Python？

在机器学习的研究和工程领域，Python 均作为首选语言而存在，总结来看主要有以下原因

- 成熟的生态: 有 `PyTroch, TensorFlow, Numpy, OpenCV-python, scikit-learn, Matplotlib, Seaborn...`，简单来说，在 Python 的世界，几乎可以只用几行 `import` 就能够搭起一个完整的以及 SOTA 的 ML 工作流，而无需重复造轮子。Python 的生态能够发展起来，实际应该归功于 `Numpy, SciPy, scikit-learn` 等的开发（由于语言特性，科研人员可以方便地使用），因此在深度学习浪潮来临的时候，科研界就选择了 Python，然后其生态就如滚雪球一般快速成长了起来，风靡了科研界和工业界
- 低门槛，高开发效率：语法简单，可读性强，使用者可以更专注于算法和逻辑本身，而非内存管理，指针和编译等问题。
- 胶水语言：由于语法简单和动态特性，以及语言设计之初就被考虑的扩展性(CPython 提供了一套 C API，因此 Python 可以直接调用 C/C++ 编写的函数)，让它比其它更复杂，且缺乏交互性的语言（如 C++）更适合作为胶水性质的语言存在。

在 CV 领域，不得不提到 C++，因为在传统图像算法领域，C++ 扮演着极其关键的角色，大多数算法是由 C++ 直接开发的。而到了今天，C++ 更多作为基石和生产环境应用的编码语言而存在。因为 Python 本身的性能劣势，几乎所有的 Python AI 生态都是由 C/C++ 构建起来的。而在生产环境中，由于资源受限和极致性能的要求，如推理等任务就会交由 C++ 实现。

至此 Python 的关键性已经不言而喻，那么作为一个有着成为 Senior MLE 志向的工程师，而非一个脚本小子，就有必要理解如何写出更好，更容易维护的 Python 程序，而非仅仅追求能够将功能实现。因此在正式开始探索机器学习领域之前，认识到 Python 的工程化就极为重要。

## Why Python 工程化？

- 代码质量与可维护性：
  - 未工程化：代码逻辑胡乱，命名随意，模块高度耦合，当需要修改 bug 或者添加新功能时，修改成本极高，且容易引入新的 bug。
  - 工程化后：遵循编码规范（如 PEP 8），采用模块化设计，同时编写清晰的文档和注释，这不仅让代码变得容易理解，而且使得未来的维护，重构和功能扩展变得轻松。

- 健壮性和可靠性：
  - 未工程化：没有单元测试，没有集成测试，没有异常处理。
  - 工程化后：严格的单元测试，集成测试和异常处理机制，能确保代码在各种边界条件下都能按预期工作。

- 提升团队效率：
  - 未工程化：每个人的开发环境，代码风格和依赖库版本都不一样，A 写的代码在 B 的环境中跑不起来。代码合并时充满冲突，而且项目目录结构不清晰，协作效率极低。
  - 工程化后：统一的开发环境，统一的代码风格，清晰的项目目录结构，规范的版本控制。

- 交付工作流：
  - 未工程化：充斥着人工操作，依赖于记忆或部署文档，非常容易出错。
  - 工程化后：通过 CI/CD 流程，将测试，打包和部署等步骤自动化，减轻了人为失误的风险，为项目的持久运行提供保障。

总之，Python 的工程化就是解决 Python 项目的规模化和长期性的问题。

## 代码质量的工程化

### 模块化

就是将一个庞大的，复杂的软件系统，拆分成一系列更小的，独立的模块的过程。基于高内聚，低耦合的拆分原则。模块化将软件变得易于维护，可扩展和可靠。

- 高内聚：
  - 含义：一个模块只做一件事，并把它做好。也就是一个模块里的类/函数/变量都应该服务于一个单一的，清晰的目的。
  - 例子：一个 `database.py` 模块应该只包含与数据库连接，查询，写入相关的代码。它不应该直到任何ui相关的内容。
  - 好处：极大地降低开发和维护的心智负担，且可以将不同模块分发给不同的人员进行维护。
- 低耦合：
  - 含义：模块之间应尽可能少地相互依赖。
  - 例子：比如一个 `user.py` 负责用户的注册，登录和注销，它不应该直接去写 SQL 查询语句，而应该去调用 `database.py` 模块提供的一个公共函数，如 `database.register_user(email, password)`。
  - 好处：假如数据库由 MySQL 切换为了 PostgreSQL，`user.py` 无需关注这些变化，只要 `database.py` 模块的维护者确保这个接口函数还可以使用，那么 `user.py` 的维护者无需更改一行代码。

基于上述原则进行软件系统的模块化，开发团队将获得极大的收益。

- 可维护性：当出现bug，我们不再需要大海捞针。如果 `支付` 功能出现问题，我们只需要去检查 `payment.py` 模块。

- 可复用性：假设在项目 A 中，我们编写了一个功能强大的模块 `a.py`, 然后我们可以在任何新项目中使用 `import a` 来重用这些功能，而不用重新开发。

- 可测试性：因为模块高内聚，低耦合的特性，我们可以使用 Mock 的方式，轻松地模拟外部依赖的接口（比如 `user.py` 依赖的 `database.register_user(email, password)`），而不需要一个真实运行的数据库。这是能够编写出完备的单元测试的前置条件。

- 并行开发：不同模块可以由不同的人同时开发，只要提前定义好接口（如 `database.register_user(email, password)`），就可以互补干扰地并行工作。

下面是关于 Python 的模块化的说明。

- 文件即模块。每一个 py 文件都是一个模块。

- 文件夹即包。放一个 `__init__.py` 即可。

- `import` 就是连接模块的胶水。

- 接口约束。Python 没有 public 和 private 关键字，我们约定公共接口命名为正常函数或类命名，如 `get_user()`，而对于内部实现由单下划线开头，如 `_create_db_connection()`，这是一种强烈的暗示，告诉调用者这是内部实现，调用后果自负。（因为内部实现可能这个版本存在下个版本就消失了，而公共接口的变更是一件非常重大的事情，常规来说会一直被维护）

- 模块的起点，一定是一个 `.py` 文件，我们所要确保的，就是它的高内聚。只要它的职责是单一的，就不存在说，因为代码行数过多而需要拆分成多个 py 文件放在一个文件夹下（文件夹下的 py 文件即是子模块）。而当文件开始做多件事的时候，内聚性就被破坏了，这才是需要重构的起点。

### 面向对象

就是将现实世界或者问题域中的事物抽象为程序中的对象的方法，是一种编程范式。和面向过程不同，面向过程就是一步一步告诉计算机先做什么后做什么（具体体现就是调用完函数a，再调用函数b，以此类推），而面向对象就是构建一系列的相互协作的对象来完成任务（比如创建用户，那么就调用用户对象的创建方法，然后创建方法调用数据库对象的创建用户的方法，来实现任务，对象和对象是一种协作关系）。

每个对象都是一个独立的个体，它可以有自己的状态（数据）和行为（方法）。

三大核心原则
- 封装：
  - 本质：把数据和操作数据的逻辑捆绑在一起，并对外隐藏内部复杂的细节。
  - 好处：高内聚，由此容易理解和维护。安全，内部的数据不会被外部随意篡改。
  - 例子：一个 User 类，它内部有一个用来记录登录尝试次数的 _login_attempts 属性，并对外提供一个 login 方法，调用者可以使用 login 方法进行登录，在 login 方法内部会去检查密码以及增加 _login_attempts 属性（比如超过3次就会锁定账户），而调用者本身不知道也无法直接去修改  _login_attempts 属性。

- 继承：
  - 本质：基于一个现有的类来创建一个新类，新类将自动获得旧类的所有功能。
  - 好处：可复用性，通用的逻辑只需要在父类中写一次。可扩展性（通过多态实现），如果需要新的统一类型的对象，只需要继承父类即可，无需重写所有代码。逻辑分层，也就是子类和父类之间具备明确的 is-a 关系，使得代码更易于被人类所理解。
  - 例子：有一个代表形状的 Shape 类，它有一个 area 方法用来计算面积。Circle 类继承自 Shape 类，它获得了 area 方法，并可添加其它方法。同样 Rectangle 类也是如此。

- 多态：
  - 本质：一种接口，多种形态，允许我们以统一的方式处理不同类型的对象。
  - 优点：低耦合，调用者不需要知道子类的具体的类型。
  - 例子：对于形状，要求面积，Circle 可以调用 area 方法，Rectangle 依然可以调用 area 方法。而只要我们的调用者以父类 Shape 作为参数，那么不论是 Circle 还是 Rectangle 都可以直接被调用者使用。另外如果要添加新的形状，调用者无需更改任何代码，只要新的形状继承自 Shape，那么这个新的形状在这里就可以被调用 area 方法。这体现出了极大的代码的可扩展性。

Python 中的面向对象

- 类和实例：使用 `class` 关键字创建类，类可以进行实例化，如 `my_car = Car()`。
- 构造方法：`__init__` 方法是一个特殊方法，在类的实例化时它会被自动调用。
- self：代表实例自身。
- 封装的实现：
  - `normal_method`：代表公共的接口。
  - `_internal_method`：代表内部实现，暗示不要进行调用，因为随着版本更新可能就没了。
  - `__private_mothod`：代表私有方法，无法直接用 `*.__*(...)` 进行访问，以一种更隐晦的隐式命名存在（依然能够强行访问，但这是 code smell），但它其实并不是为了不让你访问， 而是为了防止子类集成时意外覆盖父类的方法，导致不可预知的错误。
- 继承的实现就是 `class SubClass(ParentClass)` 就好了。
- 多态的实现：
  - python 中的多态模式是 `鸭子类型`，即在运行时检测对象是否有这个方法，如果有就认为它是这个类型，没有就不是，因此是相当宽松的一种模式。很方便。但是对于大型项目的工程化来说，就需要考虑引入 `abc` 类对继承进行约束，即子类必须显式继承父类，且必须实现某些方法，这才是最佳工程实践。

### 编码规范

这是一种团队性质的契约，用来使代码变得可读，可维护以及可协作。一个最简单的道理就是，代码被阅读多过它被修改，因此让它变得容易阅读和理解，是一件很重要的事情，而编码规范就是让这件事做得更好的工程化做法。

随着代码库的增大，项目会面临熵增的考验，在这一点上，模块化和面向对象扮演着重要的角色，编码规范同样如此，只是职责不同。编码规范负责的事情就是编码的一致性。当代码风格是一致的，那么维护者就可以脱离语言层面的写法差异，而专注于对算法/业务逻辑的理解。特别是现在自动化工具的应用(Linter & Formatter)，使得实现一致的风格变得极为容易（在CI流程中自动化这一过程），更凸显了团队遵守编码规范的收益。

对于 Python，其 PEP 8 专门定义了代码风格指南，也就是 Python 的编码规范。使用如 ruff 的工具，可以很容易地将代码以 PEP 8 的规范进行约束。当然，团队内部也可以就一些规则进行自定义的改变，但是核心中的核心，就是这一个项目乃至一个团队应当遵守同一套编码规范，无论这套规范是什么。


### 类型注解

首先需要说明，类型注解是动态语言领域的课题。对于静态语言，它在编译之前，各个变量的类型就是确定的，如果将字符串赋值给一个整型变量，都不用等待运行，编译器就会抛出一个错误来提示编译无法通过。这对于工程化来说，是一件很棒的事情，但单纯作为脚本，或探索性地进行开发，这无疑会带来很大的限制。而对于动态语言，首先它就没有编译的过程，而是通过解释器进行运行，而且在解释中，语言原生支持一个变量刚刚还是字符串类型，下一行就变为整数类型。这給使用者带来了极大的自由。当然，这种自由对于工程化来说是苦难。因为这会引入很多难以排查的问题以及隐患，因为类型是不确定的。

这时候，引入了一种类型注解的概念。即采用如 `phone_number: str = "1234567"` 的方式对变量的类型进行说明。这里的标注，不是给语言解释器看的，语言解释器该怎么工作，还怎样工作。它是给维护者看的，阅读代码就可以了解这里应该（无法保证，只能说是应该，因此还需要更完备的类型检查）是什么样的类型。它是给代码编辑器看的，编辑器可以由此给出给智能的代码提示。它是给静态检查器看的，可以在代码运行之前，检查是否存在类型上的错误，如将整数赋值给注解为字符串类型的变量。可以这么说，从工程化的角度看，类型注解的价值几乎完全体现在静态检查器的应用上，当然，这一过程更多地集成在CI流程中，是一种基础性质的代码质量保证。

正常我们使用类型结合 `typing` 库进行类型注解，对于较新的 python 版本，语言本身提供了更好的注解的支持，使得类型注解变得更加容易。


对于一些如 `pydantic` 和 `fastapi` 之类的框架，它们也会使用类型注解去实现一些相应的功能，这也体现了类型注解的额外的价值吧。

### 单元测试

单元测试是一种安全网，为开发者提供信心，当开发者对代码进行了修改，如果所有测试依然能够通过，那么开发者就有自信自己没有破坏任何东西。

对比于人工手动测试，先按一个键，再按一个键，先输入什么东西，再点击什么东西。单元测试很快，常规的测试在毫秒级就可以完成。

单元测试可以精确的定位bug，因为单元测试的级别是某个函数的某种情况，因此一旦出现出现测试不通过的情况，可以马上到相应的位置去修改代码。

单元测试本身也是文档，同一团队的开发者可以根据单元测试用例，很快了解某个函数的用法。

正常来说，单元测试最多，集成测试相对少一些，端到端测试就更少，这是从测试成本和复杂度决定的。

在ci中引入单元测试，可以避免无法通过单元测试的代码合并到主要分支。

现在的最佳实践，可以是开发人员通过业务逻辑，设计单元测试的整体思路，然后由ai生成单元测试，通过开发人员审核后作为代码的安全网。在此基础上进行开发和维护。